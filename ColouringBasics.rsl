scheme ColouringBasics =
  class
    type
      Piece = Text,
      Relation = (Piece >< Piece)-set,
      Colour = Piece-set,
      Colouring = Colour-set

    value /* auxiliary functions */
      areNb : Piece >< Piece >< Relation -> Bool
      areNb(cn1, cn2, r) is (cn1, cn2) isin r \/ (cn2, cn1) isin r,

      -- a piece can't be a neighbour of itself
      -- a piece can't be a neighbour of a piece that is not in the relation
      -- a piece can't have no neighbours
      --

      isRelation : Relation -> Bool
      isRelation(r) is
        (all (p1, p2) : Piece >< Piece :- (p1, p2) isin r => p1 ~= p2),

        -- Check if a piece is assigned two or more colors.
      pieceIsOnlyColouredOnce : Colouring -> Bool
      pieceIsOnlyColouredOnce(c) is

      -- Check that every piece is colored
      everyPieceIsColoured : Colouring >< Relation -> Bool

      isCorrectColouring : Colouring >< Relation -> Bool
      isCorrectColouring(cols, r) is
        isRelation(r) /\
        (all c : Colour :-
           c isin cols =>
             (all p : Piece :-
                p isin c =>
                  ~ (exists p2 : Piece :- p2 isin c /\ areNb(p, p2, r)))),

      r : Relation =
        {("P1", "P2"), ("P1", "P3"), ("P2", "P4"), ("P2", "P5"), ("P3", "P7"),
         ("P4", "P5"), ("P4", "P6"), ("P4", "P7"), ("P4", "P8"), ("P5", "P6"),
         ("P6", "P8"), ("P7", "P8")},
      colouring : Colouring =
        {{"P1", "P4"}, {"P2", "P3", "P6"}, {"P7", "P5"}, {"P8"}}

    test_case
      [areNb_returns_true_if_pieces_are_neighbours]
        areNb("P1", "P2", r),
      [areNb_returns_true_if_pieces_are_neighbours_reversed]
        areNb("P2", "P1", r),
      [areNb_returns_false_if_pieces_are_not_neighbours]
        ~ areNb("P1", "P8", r),
      [isCorrectColouring_returns_true_if_colouring_is_correct]
        isCorrectColouring(colouring, r),
      [isCorrectColouring_returns_false_if_colouring_is_not_correct]
        ~ isCorrectColouring({{"P1", "P2"}, {"P3", "P4"}}, r)
  end
